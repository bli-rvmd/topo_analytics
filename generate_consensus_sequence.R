##############
# Begin setting runtime parameters
##############

## data folder 
data_folder <- "./data/ElimBio_Order_871831_20250127_TOPO_KPTC_Barcoding/"
sub_data_folder <- "pcr_104"
delim_clone <- c("_10-", "_M13-") ## delimiters identifying clone number
# delim_clone <- c("-11\\.", "_T[3|7]_")

## PCR primers 
fwd_primer <- toupper("ACACTCTTTCCCTACACGA")
rev_primer <- toupper("GTGACTGGAGTTCAGACG")

# # if no trimming - use these
# fwd_primer <- strrep("T", 100)
# rev_primer <- strrep("T", 100)

if_allow_one_N <- T

## number of bps to trim at beginning and end
n_trim_begin <- 20
n_trim_end <- 200

## qc threshold of %_N's in each of trimmed sequences
thres_perc_N <- 0.10 

###############
# End setting runtime parameters
###############

################################# !!! DO NOT CHANGE ANYTHING BELOW !!! ##############################

## Load required packages
library(seqinr)
library(Biostrings)
library(stringr)

# Load the necessary libraries
library(BSgenome)
# library(BSgenome.Mmusculus.UCSC.mm10) # Mouse genome assembly (mm10)
library(BSgenome.Mmusculus.UCSC.mm39) # Mouse genome assembly (mm39 2020)
library(rtracklayer)

# Define the mouse genome object
GRCm39 <- BSgenome.Mmusculus.UCSC.mm39

##############
## TOPO sequence Trimming logic
# step 1 - identify if either primer can find exact match to find directionality of the sequence
# step 2 - if fwd_primer (or rev_primer) finds match, trim off subseq upstream of beginning bp of fwd_primer (or rev_primer)
# step 3 - then check if reverse complement of rev_primer (or fwd_primer) can find match, trim off subseq downstream of ending bp of reverse complement
# step 4 (edge case #1) - for sequence that finds exact match of fwd_primer (or rev_primer), but cannot find exact match of reverse complement of rev_primer (or fwd_primer), trim off upstream of beginning of bp of fwd_primer (or rev_primer), then trim off an arbitrary 'n_trim_end" (e.g. 200) bps at the end, and save trimmed seq separately 
# step 5 (edge case #2) - for sequence that cannot find exact match of fwd_primer (or rev_primer), but can find exact match of reverse complement of rev_primer (or fwd_primer), trim off downstream of ending bp of the reverse complement and trim off an arbitrary 'n_trim_begin' (e.g. 20) bps at the beginning, and save trimmed seq separately
# step 6 (edge case #3) - for sequence that can find neither fwd_primer (or rev_primer) nor reverse complement of rev_primer (or fwd_primer), trim off arbitrary 'n_trim_begin' and 'n_trim_end' then save separately
# step 7 - for crispresso analysis, can use only sequences from step 3, and possibly adding those identified by steps 4 & 5, or further adding all including those from step 6 

## ToDo - Alternatively - implement loading fastq file (which can be generated by BioPython directly from *.ab1 files) and trim each sequence in it instead of loading *.seq files

## For each sequence after trimming also quantify %N's and discard if > certain threshold
##############


###############
# Begin utility functions
###############

## function to find reverse complement of a dna sequence
find_reverse_complement <- function(dna_seq) {
  dna_seq <- DNAString(dna_seq)
  return (as.character(reverseComplement(dna_seq)))
}

## function to find location of dna_seq in a reference_seq allowing up to 1 bp of N (ambiguous call)
find_seq_location_in_amplicon <- function(dna_seq, ref_seq, allow_one_N = FALSE) {
  
  # if not allowing any bp = N
  if (!allow_one_N) {
    
    dna_seqs <- c(dna_seq)
    
  } else {
    
    # if allowing one N
    dna_seqs <- sapply(1:nchar(dna_seq), function(idx) {
      
      tmp <- substring(dna_seq, 1, idx - 1)
      tmp <- paste0(tmp, "N")
      tmp <- paste0(tmp, substring(dna_seq, idx + 1))
      
      tmp
    })
    # adding the original seq
    dna_seqs <- c(dna_seq, dna_seqs)
    
  }
  
 for (ss in dna_seqs) {
    idx <- stringr::str_locate(ref_seq, ss)[[1]]
    if (!is.na(idx)) {
      return (idx)
    }
  }
  
  return (NA)
}

## function applying sequence trimming logic
apply_seq_trimming <- function(ref_seq, # reference sequence to apply trimming on 
                               fp,  # forward primer sequence
                               rp,  # reverse primer sequence
                               allow_one_N = FALSE,  # allowing one bp of N or not
                               n_bp_begin = 20, # for edge cases of having to trim by arbitrary number of bps at beginning
                               n_bp_end = 200 # for edge cases of having to trim by arbitray number of bps at the end
                               ) {
  
  # note on status of fp matching
  fp_matching <- find_seq_location_in_amplicon(fp, ref_seq, allow_one_N = allow_one_N)
  
  # note on status of reverse complement of rp matching
  rp_rc_matching <- find_seq_location_in_amplicon(find_reverse_complement(rp), ref_seq, allow_one_N = allow_one_N)
  
  # note on status of rp matching
  rp_matching <- find_seq_location_in_amplicon(rp, ref_seq, allow_one_N = allow_one_N)
  
  # note on status of reverse complement of fp matching
  fp_rc_matching <- find_seq_location_in_amplicon(find_reverse_complement(fp), ref_seq, allow_one_N = allow_one_N)
  
  # # categorize cases
  # case_counts <- list(
  #   "forward_in_rc_reverse_in" = 0, # usual cases
  #   "reverse_in_rc_forward_in" = 0, 
  #   
  #   "forward_in_rc_reverse_out" = 0, # edge case #1
  #   "reverse_in_rc_forward_out" = 0, 
  #   
  #   "forward_out_rc_reverse_in" = 0, # edge case #2
  #   "reverse_out_rc_forward_in" = 0, 
  #   
  #   "forward_out_rc_reverse_out" = 0, # edge case #3
  #   "reverse_out_rc_forward_out" = 0
  # )
  
  # usual cases, forward_in_rc_reverse_in or reverse_in_rc_forward_in
  if (!is.na(fp_matching) & !is.na(rp_rc_matching)) {
    # trimmed seq starts at fp_matching, and ends at rp_rc_matching + length(reverse primer) - 1
    trimmed_seq <- substr(ref_seq, start = fp_matching, stop = rp_rc_matching + nchar(rp) - 1)
    return (list(
      "trimmed_seq" = trimmed_seq, 
      "case" = "forward_in_rc_reverse_in"
    ))
  }
  
  if (!is.na(rp_matching) & !is.na(fp_rc_matching)) {
    trimmed_seq <- substr(ref_seq, start = rp_matching, stop = fp_rc_matching + nchar(fp) - 1)
    return (list(
      "trimmed_seq" = trimmed_seq, 
      "case" = "reverse_in_rc_forward_in"
    ))
  }
  
  # edge case #1, forward_in_rc_reverse_out or reverse_in_rc_forward_out
  if (!is.na(fp_matching) & is.na(rp_rc_matching)) {
    # trimmed seq starts at fp_matching, and ends at nchar(ref_seq) - n_bp_end 
    trimmed_seq <- substr(ref_seq, start = fp_matching, stop = nchar(ref_seq) - n_bp_end)
    return (list(
      "trimmed_seq" = trimmed_seq, 
      "case" = "forward_in_rc_reverse_out"
    ))
  }
  
  if (!is.na(rp_matching) & is.na(fp_rc_matching)) {
    trimmed_seq <- substr(ref_seq, start = rp_matching, stop = nchar(ref_seq) - n_bp_end)
    return (list(
      "trimmed_seq" = trimmed_seq, 
      "case" = "reverse_in_rc_forward_out"
    ))
  }
  
  # edge case #2, forward_out_rc_reverse_in or reverse_out_rc_forward_in
  if (is.na(fp_matching) & !is.na(rp_rc_matching)) {
    # trimmed seq starts at n_bp_begin + 1, and ends at rp_rc_matching + length(reverse primer) - 1
    trimmed_seq <- substr(ref_seq, start = n_bp_begin + 1, stop = rp_rc_matching + nchar(rp) - 1)
    return (list(
      "trimmed_seq" = trimmed_seq, 
      "case" = "forward_out_rc_reverse_in"
    ))
  }
  
  if (is.na(rp_matching) & !is.na(fp_rc_matching)) {
    trimmed_seq <- substr(ref_seq, start = n_bp_begin + 1, stop = fp_rc_matching + nchar(fp) - 1)
    return (list(
      "trimmed_seq" = trimmed_seq, 
      "case" = "reverse_out_rc_forward_in"
    ))
  }
  
  # edge case #3, forward_out_rc_reverse_out or reverse_out_rc_forward_out" 
  # none of forward, rc_forward, reverse, or rc_reverse can find match
  return(list(
    "trimmed_seq" = substr(ref_seq, start = n_bp_begin + 1, stop = nchar(ref_seq) - n_bp_end), 
    "case" = "all_out"
  ))
  
}
  

## find matches of a seq in GRCm39
find.seq.match.grcm39 <- function(dna_seq) {
  
  # reverse complement of dna_seq
  rev_dna_seq <- Biostrings::reverseComplement(Biostrings::DNAString(dna_seq))
  
  # find matches of reference seq in GRCm39
  res_seq_query <- data.frame()
  
  chrs <- GenomeInfoDb::seqnames(GRCm39)
  
  for (chr in chrs[!grepl("_", chrs)]) {
    
    chr_sequence <- GRCm39[[chr]]
    
    # print(paste0(idx, ": ", chr))
    print(chr)
    
    # find matches of chr_sequence
    match_positions <- Biostrings::matchPattern(dna_seq, chr_sequence)
    
    if (length(match_positions) > 0) {
      print(paste("Found match on chromosome", chr))
      print(match_positions)
      
      res_seq_query <- rbind(res_seq_query, c(chr, start(match_positions), end(match_positions)))
    }
    
    # find for reverse complement of dna_seq
    match_positions_rev <- Biostrings::matchPattern(rev_dna_seq, chr_sequence)
    
    if (length(match_positions_rev) > 0) {
      print(paste("Found match of reverse complement on chromosome", chr))
      print(match_positions_rev)
      
      res_seq_query <- rbind(res_seq_query, c(chr, start(match_positions_rev), end(match_positions_rev)))
    }
    
  }
  
  colnames(res_seq_query) <- c("chr", "start", "end") 
  
  return (res_seq_query)
  # 
  # # stop if there are multiple matches of a reference sequence
  # if (nrow(res_seq_query) != 1) {
  #   
  #   print(res_seq_query)
  #   stop(paste0("Check row ", idx, " of sequence that it has multiple matches in the GRCm39 genome!\n"))
  # }
  # 
}

## traverse data folder identifying clones
seq_files <- list.files(path = file.path(data_folder, sub_data_folder), pattern = "\\.seq$", full.names = TRUE)
clone_ids <- unique(
  stringr::str_extract(seq_files, paste0("(?<=\\", delim_clone[1], ").*?(", "?=\\", delim_clone[2], ")")))

list_clone_seqs <- list(
  "forward_in_rc_reverse_in" = c(), 
  "reverse_in_rc_forward_in" = c(), 
  
  "forward_in_rc_reverse_out" = c(), 
  "reverse_in_rc_forward_out" = c(), 
  
  "forward_out_rc_reverse_in" = c(), 
  "reverse_out_rc_forward_in" = c(), 
  
  "all_out" = c()
)

for (c_id in clone_ids) {
  # print(c_id)
  
  # locate pair of seq files
  c_seq_files <- grep(paste0("\\", delim_clone[1], c_id, delim_clone[2]), seq_files, value = TRUE)
  
  for (seq_file in c_seq_files) {
    
    s <- toupper(paste(read.fasta(file = seq_file)[[1]], collapse = ""))
    
    res_s <- apply_seq_trimming(s, fp = fwd_primer, rp = rev_primer, allow_one_N = if_allow_one_N)
    list_clone_seqs[[res_s$case]] <- c(list_clone_seqs[[res_s$case]], res_s$trimmed_seq) 
    
    if (res_s$case == "forward_in_rc_reverse_out") {
      
      print(seq_file)
      
    }
    
  }
  
}


## extract sequences
seqs_both_primers_in <- c()
seqs_at_least_one_primer_in <- c()
seqs_all <- c()
for (x in names(list_clone_seqs)) {
  
  if (x %in% c("forward_in_rc_reverse_in", "reverse_in_rc_forward_in")) {
    seqs_both_primers_in <- c(seqs_both_primers_in, list_clone_seqs[[x]])
    seqs_at_least_one_primer_in <- c(seqs_at_least_one_primer_in, list_clone_seqs[[x]])
    seqs_all <- c(seqs_all, list_clone_seqs[[x]])
  }
  
  else if (x == "all_out") {
    seqs_all <- c(seqs_all, list_clone_seqs[[x]])
  }
  
  else {
    seqs_at_least_one_primer_in <- c(seqs_at_least_one_primer_in, list_clone_seqs[[x]])
    seqs_all <- c(seqs_all, list_clone_seqs[[x]])
  }
}


## create fastq files for seqs_both_primers_in, seqs_at_least_one_primer_in, and seqs_all
create_fastq_file_from_seqs <- function(seqs, output_file_name) {
  
  fwd_fastq <- c()
  
  for (idx in 1:length(seqs)) {
    
    fwd_fastq <- c(fwd_fastq, paste0("@AB00001:123:12ABCDEFH:1:1:1:", idx, " 1:N:0:AAAAAAAA+GGGGGGGG"))
    
    fwd_fastq <- c(fwd_fastq, seqs[idx])
    
    fwd_fastq <- c(fwd_fastq, "+")
    
    tmp <- gsub("N", "#", seqs[idx])
    tmp <- gsub("[^#]", "I", tmp)
    
    fwd_fastq <- c(fwd_fastq, tmp)
    
  }
  
  writeLines(fwd_fastq, con = output_file_name)
}


create_fastq_file_from_seqs(seqs_both_primers_in, output_file_name = paste0(data_folder, sub_data_folder, "/", sub_data_folder, "_seqs_both_primers_in.fastq"))
create_fastq_file_from_seqs(seqs_at_least_one_primer_in, output_file_name = paste0(data_folder, sub_data_folder, "/", sub_data_folder, "_seqs_at_least_one_primer_in.fastq"))
create_fastq_file_from_seqs(seqs_all, output_file_name = paste0(data_folder, sub_data_folder, "/", sub_data_folder, "_seqs_all.fastq"))

for (x in names(list_clone_seqs)) {
  print(paste0(x, ": ", length(list_clone_seqs[[x]])))
}

# further filter out seqs_all by %N's 
filtered_seqs_all <- c()

for (s in seqs_all) {
  
  total_chars <- nchar(s)
  
  count_N <- sum(strsplit(s, NULL)[[1]] == "N")
  
  percentage_N <- count_N / total_chars
  
  if (is.nan(percentage_N) | percentage_N > thres_perc_N) {
    
    print(s)
    print(paste0("An empty sequence or Percentage of N's is at ", percentage_N * 100, "%!"))
    
  } else {
    filtered_seqs_all <- c(filtered_seqs_all, s)
  }
}

####
# further filter out seqs_all by new QC of removing potential primer dimers
####
# 
# ## fwd_ and rev_primers seq matches
# fp_seq_match <- find.seq.match.grcm39(fwd_primer)
# rp_seq_match <- find.seq.match.grcm39(rev_primer)
# 
# ## fwd_ and rev_primers getSeq(...)
# fp_getSeq <- as.character(Biostrings::getSeq(GRCm39, 
#                                 names = fp_seq_match$chr, 
#                                 start = as.integer(fp_seq_match$start), 
#                                 end = as.integer(fp_seq_match$end)))
# rp_getSeq <- as.character(Biostrings::getSeq(GRCm39, 
#                                 names = rp_seq_match$chr, 
#                                 start = as.integer(rp_seq_match$start), 
#                                 end = as.integer(rp_seq_match$end)))
# 
# ## directionality (5' -> 3' or 3' to 5') of fwd and rev primers
# if (fwd_primer == fp_getSeq) { # fwd_primer is in 5' to 3' direction
#   
#   fp_direction <- '5to3'
#   
#   # sequence of fwd_primer plus its downstream of n bps 
#   fp_seq_plus_nbp <- as.character(Biostrings::getSeq(GRCm39, 
#                                                      names = fp_seq_match$chr, 
#                                                      start = as.integer(fp_seq_match$start), 
#                                                      end = as.integer(fp_seq_match$end) + n_bps_to_align))
#   
#   # sequence of fwd_primer's upstream of n bps plus itself
#   nbp_plus_fp_seq <- as.character(Biostrings::getSeq(GRCm39, 
#                                                      names = fp_seq_match$chr, 
#                                                      start = as.integer(fp_seq_match$start) - n_bps_to_align, 
#                                                      end = as.integer(fp_seq_match$end)))
#   
# } else if (fwd_primer == find_reverse_complement(fp_getSeq)) { # fwd_primer is in 3' to 5' direction
#   
#   fp_direction <- '3to5'
#   
#   fp_seq_plus_nbp <- as.character(Biostrings::getSeq(GRCm39, 
#                                                      names = fp_seq_match$chr, 
#                                                      start = as.integer(fp_seq_match$start) - n_bps_to_align, 
#                                                      end = as.integer(fp_seq_match$end)))
#   
#   nbp_plus_fp_seq <- as.character(Biostrings::getSeq(GRCm39, 
#                                                      names = fp_seq_match$chr, 
#                                                      start = as.integer(fp_seq_match$start), 
#                                                      end = as.integer(fp_seq_match$end) + n_bps_to_align))
#   
# } else {
#   stop("check fwd_primer sequence that neither itself nor its reverse complement can find exact match in GRCm39!")
# }
# 
# if (rev_primer == rp_getSeq) { # rev_primer is in 5' to 3' direction
#   
#   rp_direction <- '5to3' 
#   
#   rp_seq_plus_nbp <- as.character(Biostrings::getSeq(GRCm39, 
#                                                      names = rp_seq_match$chr, 
#                                                      start = as.integer(rp_seq_match$start), 
#                                                      end = as.integer(rp_seq_match$end) + n_bps_to_align))
#   
#   nbp_plus_rp_seq <- as.character(Biostrings::getSeq(GRCm39, 
#                                                      names = rp_seq_match$chr, 
#                                                      start = as.integer(rp_seq_match$start) - n_bps_to_align, 
#                                                      end = as.integer(rp_seq_match$end)))
#   
# } else if (rev_primer == find_reverse_complement(rp_getSeq)) { # rev_primer is in 3' to 5' direction
#   
#   rp_direction <- '3to5'
#   
#   rp_seq_plus_nbp <- as.character(Biostrings::getSeq(GRCm39, 
#                                                      names = rp_seq_match$chr, 
#                                                      start = as.integer(rp_seq_match$start) - n_bps_to_align, 
#                                                      end = as.integer(rp_seq_match$end)))
#   
#   nbp_plus_rp_seq <- as.character(Biostrings::getSeq(GRCm39, 
#                                                      names = rp_seq_match$chr, 
#                                                      start = as.integer(rp_seq_match$start), 
#                                                      end = as.integer(rp_seq_match$end) + n_bps_to_align))
#   
# } else {
#   stop("check rev_primer sequence that neither itself nor its reverse complement can find exact match in GRCm39!")
# }
# 
# 
# ## run options for iterating through filtered_seqs_all
# filtered_seqs_all_qc <- c()
# n_bps_to_align <- 5
# count_primer_dimers <- 0
# 
# 
# for (idx in 1:length(filtered_seqs_all)) {
#   
#   s <- filtered_seqs_all[idx]
#   
#   ## find locations of fwd_/rev_primers and their reverse complements in s
#   fp_location_in_s <- find_seq_location_in_amplicon(fwd_primer, s, allow_one_N = T)
#   rp_location_in_s <- find_seq_location_in_amplicon(rev_primer, s, allow_one_N = T)
#   
#   rc_fp_location_in_s <- find_seq_location_in_amplicon(find_reverse_complement(fwd_primer), s, allow_one_N = T)
#   rc_rp_location_in_s <- find_seq_location_in_amplicon(find_reverse_complement(rev_primer), s, allow_one_N = T)
#   
#   
#   ## if s begins with fwd_primer (allowing one N in primer seq, and considering either scenario of 5to3 and 3to5 of fwd_primer directionality)
#   if ((!is.na(fp_location_in_s) & fp_location_in_s == 1) | (!is.na(rc_fp_location_in_s) & rc_location_in_s == 1)) {
#     
#     print(paste0("seq ", idx, " begins with fwd_primer"))
#     
#     # check if n_bps_to_align next to primer can be perfectly aligned (allowing one N) or not
#     if (fp_direction == "5to3") { # if fwd_primer direction is 5' to 3'
#       
#       tmp_seq <- fp_seq_plus_nbp
#       
#     } else { # if fwd_primer direction is 3' to 5'
#       
#       tmp_seq <- find_reverse_complement(fp_seq_plus_nbp)
#       
#     }
#     
#     # check if tmp_seq equals to or not substr(s, 1, nchar(tmp_seq))
#     if (tmp_seq == substr(s, 1, nchar(tmp_seq))) { # tmp_seq matches
#       
#       filtered_seqs_all_qc <- c(filtered_seqs_all_qc, s)
#       print(paste0("initial subseq fully aligns"))
#       
#     } else { # tmp_seq doesn't match -> primer dimer
#       
#       print(paste0("initial subseq does not align, likely a primer dimer: ", tmp_seq, " vs ", substr(s, 1, nchar(tmp_seq))))
#       count_primer_dimers <- count_primer_dimers + 1
#       
#     }
#     
#     # move to next sequence
#     next 
#     
#   }
#   
#   
#   ## if s begins with rev_primer (allowing one N in primer seq)
#   if (!is.na(rp_location_in_s) & rp_location_in_s == 1) {
#     
#     print(paste0("seq ", idx, " begins with rev_primer"))
#     
#     # check if n_bps_to_align next to primer can be perfectly aligned or not
#     if (rp_direction == "5to3") { # if rev_primer direction is 5to3
#       tmp_seq <- rp_seq_plus_nbp
#     } else { # if rev_primer direction is 3to5
#       tmp_seq <- find_reverse_complement(rp_seq_plus_nbp)
#     }
#     
#     # check if tmp_seq matches or not substr(s, 1, nchar(tmp_seq))
#     if (tmp_seq == substr(s, 1, nchar(tmp_seq))) {
#       filtered_seqs_all_qc <- c(filtered_seqs_all_qc, s)
#       print(paste0("initial subset fully aligns"))
#     } else {
#       print(paste0("initial subset does not, likely a primer dimer: ", tmp_seq, " vs ", substr(s, 1, nchar(tmp_seq))))
#       count_primer_dimers <- count_primer_dimers + 1
#     }
#     
#     # move to next sequence 
#     next
#   }
#   
#   ## if s ends with fwd_primer
#   if (!is.na(rc_fp_location_in_s) & rc_fp_location_in_s == nchar(s) - nchar(fwd_primer) + 1) {
#     
#     print(paste0("seq ", idx, " ends with fwd_primer"))
#     
#     # check if n_bps_to_align upstream of primer can be perfectly aligned (allowing one N) or not
#     if (fp_direction == "5to3") { # if fwd_primer is in 5' -> 3' direction 
#       tmp_seq <- nbp_plus_fp_seq
#     } else { # if fwd_primer direction is 3' to 5'
#       tmp_seq <- find_reverse_complement(nbp_plus_fp_seq)
#     }
#     
#     # check if tmp_seq equals to or not substr(s, nchar(s) - nchar(tmp_seq) + 1, nchar(s))
#     if (tmp_seq == substr(s, nchar(s) - nchar(tmp_seq) + 1, nchar(s))) {
#       filtered_seq_all_qc <- c(filtered_seq_all_qc, s)
#       print(paste0("ending subseq fully aligns"))
#     } else {
#       print(paste0("ending subseq does not align, likely a primer dimer: ", tmp_seq, " vs ", substr(s, nchar(s) - nchar(tmp_seq) + 1, nchar(s))))
#       count_primer_dimers <- count_primer_dimers + 1
#     }
#     # move to next sequence
#     next
#   }
#   
#   ## if s ends with rev_primer
#   if (!is.na(rc_rp_location_in_s) & rc_rp_location_in_s == nchar(s) - nchar(rev_primer) + 1) {
#     
#     print(paste0("seq ", idx, " ends with rev_primer"))
#     
#     # check if n_bps_to_align upstream of primer can be perfectly aligned or not
#     if (rp_direction == "5to3") { # if rev_primer direction is 5to3
#       tmp_seq <- nbp_plus_rp_seq
#     } else { # if rev_primer is 3to5
#       tmp_seq <- find_reverse_complement(nbp_plus_rp_seq)
#     }
#     
#     # check if tmp_seq matches or not substr(s, nchar(s) - nchar(tmp_seq) + 1, nchars())
#     if(tmp_seq == substr(s, nchar(s) - nchar(tmp_seq) + 1, nchar(s))) {
#       filtered_seq_all_qc <- c(filtered_seq_all_qc, s)
#       print(paste0("ending subseq fully aligns"))
#     } else {
#       
#     }
#       
#       
#   }
#   
# }



create_fastq_file_from_seqs(filtered_seqs_all, output_file_name = paste0(data_folder, sub_data_folder, "/", sub_data_folder, "_filtered_seqs_all.fastq"))

