##############
# Begin setting runtime parameters
##############

## data folder 
data_folder <- "./data/20240917_TOPO_ElimBio_order_8670874_cdkn2a_2b_Mtap_large_deletion//"
sub_data_folder <- "pcr_33"
delim_clone <- c("_3-", "_M13-") ## delimiters identifying clone number

## PCR primers 
fwd_primer <- toupper("AGAACTGGCAGTAATGCGCT")
rev_primer <- toupper("CCACCCCACTAGAAACGTCA")

if_allow_one_N <- T

## number of bps to trim at beginning and end
n_trim_begin <- 20
n_trim_end <- 200

## qc threshold of %_N's in each of trimmed sequences
thres_perc_N <- 0.10 

###############
# End setting runtime parameters
###############

################################# !!! DO NOT CHANGE ANYTHING BELOW !!! ##############################

## Load required packages
library(seqinr)
library(Biostrings)
library(stringr)

##############
## TOPO sequence Trimming logic
# step 1 - identify if either primer can find exact match to find directionality of the sequence
# step 2 - if fwd_primer (or rev_primer) finds match, trim off subseq upstream of beginning bp of fwd_primer (or rev_primer)
# step 3 - then check if reverse complement of rev_primer (or fwd_primer) can find match, trim off subseq downstream of ending bp of reverse complement
# step 4 (edge case #1) - for sequence that finds exact match of fwd_primer (or rev_primer), but cannot find exact match of reverse complement of rev_primer (or fwd_primer), trim off upstream of beginning of bp of fwd_primer (or rev_primer), then trim off an arbitrary 'n_trim_end" (e.g. 200) bps at the end, and save trimmed seq separately 
# step 5 (edge case #2) - for sequence that cannot find exact match of fwd_primer (or rev_primer), but can find exact match of reverse complement of rev_primer (or fwd_primer), trim off downstream of ending bp of the reverse complement and trim off an arbitrary 'n_trim_begin' (e.g. 20) bps at the beginning, and save trimmed seq separately
# step 6 (edge case #3) - for sequence that can find neither fwd_primer (or rev_primer) nor reverse complement of rev_primer (or fwd_primer), trim off arbitrary 'n_trim_begin' and 'n_trim_end' then save separately
# step 7 - for crispresso analysis, can use only sequences from step 3, and possibly adding those identified by steps 4 & 5, or further adding all including those from step 6 

## ToDo - Alternatively - implement loading fastq file (which can be generated by BioPython directly from *.ab1 files) and trim each sequence in it instead of loading *.seq files

## For each sequence after trimming also quantify %N's and discard if > certain threshold
##############


###############
# Begin utility functions
###############

## function to find reverse complement of a dna sequence
find_reverse_complement <- function(dna_seq) {
  dna_seq <- DNAString(dna_seq)
  return (as.character(reverseComplement(dna_seq)))
}

## function to find location of dna_seq in a reference_seq allowing up to 1 bp of N (ambiguous call)
find_seq_location_in_amplicon <- function(dna_seq, ref_seq, allow_one_N = FALSE) {
  
  # if not allowing any bp = N
  if (!allow_one_N) {
    
    dna_seqs <- c(dna_seq)
    
  } else {
    
    # if allowing one N
    dna_seqs <- sapply(1:nchar(dna_seq), function(idx) {
      
      tmp <- substring(dna_seq, 1, idx - 1)
      tmp <- paste0(tmp, "N")
      tmp <- paste0(tmp, substring(dna_seq, idx + 1))
      
      tmp
    })
    # adding the original seq
    dna_seqs <- c(dna_seq, dna_seqs)
    
  }
  
 for (ss in dna_seqs) {
    idx <- stringr::str_locate(ref_seq, ss)[[1]]
    if (!is.na(idx)) {
      return (idx)
    }
  }
  
  return (NA)
}

## function applying sequence trimming logic
apply_seq_trimming <- function(ref_seq, # reference sequence to apply trimming on 
                               fp,  # forward primer sequence
                               rp,  # reverse primer sequence
                               allow_one_N = FALSE,  # allowing one bp of N or not
                               n_bp_begin = 20, # for edge cases of having to trim by arbitrary number of bps at beginning
                               n_bp_end = 200 # for edge cases of having to trim by arbitray number of bps at the end
                               ) {
  
  # note on status of fp matching
  fp_matching <- find_seq_location_in_amplicon(fp, ref_seq, allow_one_N = allow_one_N)
  
  # note on status of reverse complement of rp matching
  rp_rc_matching <- find_seq_location_in_amplicon(find_reverse_complement(rp), ref_seq, allow_one_N = allow_one_N)
  
  # note on status of rp matching
  rp_matching <- find_seq_location_in_amplicon(rp, ref_seq, allow_one_N = allow_one_N)
  
  # note on status of reverse complement of fp matching
  fp_rc_matching <- find_seq_location_in_amplicon(find_reverse_complement(fp), ref_seq, allow_one_N = allow_one_N)
  
  # # categorize cases
  # case_counts <- list(
  #   "forward_in_rc_reverse_in" = 0, # usual cases
  #   "reverse_in_rc_forward_in" = 0, 
  #   
  #   "forward_in_rc_reverse_out" = 0, # edge case #1
  #   "reverse_in_rc_forward_out" = 0, 
  #   
  #   "forward_out_rc_reverse_in" = 0, # edge case #2
  #   "reverse_out_rc_forward_in" = 0, 
  #   
  #   "forward_out_rc_reverse_out" = 0, # edge case #3
  #   "reverse_out_rc_forward_out" = 0
  # )
  
  # usual cases, forward_in_rc_reverse_in or reverse_in_rc_forward_in
  if (!is.na(fp_matching) & !is.na(rp_rc_matching)) {
    # trimmed seq starts at fp_matching, and ends at rp_rc_matching + length(reverse primer) - 1
    trimmed_seq <- substr(ref_seq, start = fp_matching, stop = rp_rc_matching + nchar(rp) - 1)
    return (list(
      "trimmed_seq" = trimmed_seq, 
      "case" = "forward_in_rc_reverse_in"
    ))
  }
  
  if (!is.na(rp_matching) & !is.na(fp_rc_matching)) {
    trimmed_seq <- substr(ref_seq, start = rp_matching, stop = fp_rc_matching + nchar(fp) - 1)
    return (list(
      "trimmed_seq" = trimmed_seq, 
      "case" = "reverse_in_rc_forward_in"
    ))
  }
  
  # edge case #1, forward_in_rc_reverse_out or reverse_in_rc_forward_out
  if (!is.na(fp_matching) & is.na(rp_rc_matching)) {
    # trimmed seq starts at fp_matching, and ends at nchar(ref_seq) - n_bp_end 
    trimmed_seq <- substr(ref_seq, start = fp_matching, stop = nchar(ref_seq) - n_bp_end)
    return (list(
      "trimmed_seq" = trimmed_seq, 
      "case" = "forward_in_rc_reverse_out"
    ))
  }
  
  if (!is.na(rp_matching) & is.na(fp_rc_matching)) {
    trimmed_seq <- substr(ref_seq, start = rp_matching, stop = nchar(ref_seq) - n_bp_end)
    return (list(
      "trimmed_seq" = trimmed_seq, 
      "case" = "reverse_in_rc_forward_out"
    ))
  }
  
  # edge case #2, forward_out_rc_reverse_in or reverse_out_rc_forward_in
  if (is.na(fp_matching) & !is.na(rp_rc_matching)) {
    # trimmed seq starts at n_bp_begin + 1, and ends at rp_rc_matching + length(reverse primer) - 1
    trimmed_seq <- substr(ref_seq, start = n_bp_begin + 1, stop = rp_rc_matching + nchar(rp) - 1)
    return (list(
      "trimmed_seq" = trimmed_seq, 
      "case" = "forward_out_rc_reverse_in"
    ))
  }
  
  if (is.na(rp_matching) & !is.na(fp_rc_matching)) {
    trimmed_seq <- substr(ref_seq, start = n_bp_begin + 1, stop = fp_rc_matching + nchar(fp) - 1)
    return (list(
      "trimmed_seq" = trimmed_seq, 
      "case" = "reverse_out_rc_forward_in"
    ))
  }
  
  # edge case #3, forward_out_rc_reverse_out or reverse_out_rc_forward_out" 
  # none of forward, rc_forward, reverse, or rc_reverse can find match
  return(list(
    "trimmed_seq" = substr(ref_seq, start = n_bp_begin + 1, stop = nchar(ref_seq) - n_bp_end), 
    "case" = "all_out"
  ))
  
}
  

## obtain amplicon sequence
# amplicon_seq <- readDNAStringSet(amplicon_fasta_file)[1]

# # categorize cases
# case_counts <- list(
#   "forward_in_rc_reverse_in" = 0, # usual cases
#   "reverse_in_rc_forward_in" = 0, 
#   
#   "forward_in_rc_reverse_out" = 0, # edge case #1
#   "reverse_in_rc_forward_out" = 0, 
#   
#   "forward_out_rc_reverse_in" = 0, # edge case #2
#   "reverse_out_rc_forward_in" = 0, 
#   
#   "forward_out_rc_reverse_out" = 0, # edge case #3
#   "reverse_out_rc_forward_out" = 0
# )

## traverse data folder identifying clones
seq_files <- list.files(path = file.path(data_folder, sub_data_folder), pattern = "\\.seq$", full.names = TRUE)
clone_ids <- unique(
  stringr::str_extract(seq_files, paste0("(?<=\\", delim_clone[1], ").*?(", "?=\\", delim_clone[2], ")")))

list_clone_seqs <- list(
  "forward_in_rc_reverse_in" = c(), 
  "reverse_in_rc_forward_in" = c(), 
  
  "forward_in_rc_reverse_out" = c(), 
  "reverse_in_rc_forward_out" = c(), 
  
  "forward_out_rc_reverse_in" = c(), 
  "reverse_out_rc_forward_in" = c(), 
  
  "all_out" = c()
)

for (c_id in clone_ids) {
  # print(c_id)
  
  # locate pair of seq files
  c_seq_files <- grep(paste0("\\", delim_clone[1], c_id, delim_clone[2]), seq_files, value = TRUE)
  
  for (seq_file in c_seq_files) {
    
    s <- toupper(paste(read.fasta(file = seq_file)[[1]], collapse = ""))
    
    res_s <- apply_seq_trimming(s, fp = fwd_primer, rp = rev_primer, allow_one_N = if_allow_one_N)
    list_clone_seqs[[res_s$case]] <- c(list_clone_seqs[[res_s$case]], res_s$trimmed_seq) 
    
    if (res_s$case == "forward_in_rc_reverse_out") {
      
      print(seq_file)
      
    }
    
  }
  
}


## extract sequences
seqs_both_primers_in <- c()
seqs_at_least_one_primer_in <- c()
seqs_all <- c()
for (x in names(list_clone_seqs)) {
  
  if (x %in% c("forward_in_rc_reverse_in", "reverse_in_rc_forward_in")) {
    seqs_both_primers_in <- c(seqs_both_primers_in, list_clone_seqs[[x]])
    seqs_at_least_one_primer_in <- c(seqs_at_least_one_primer_in, list_clone_seqs[[x]])
    seqs_all <- c(seqs_all, list_clone_seqs[[x]])
  }
  
  else if (x == "all_out") {
    seqs_all <- c(seqs_all, list_clone_seqs[[x]])
  }
  
  else {
    seqs_at_least_one_primer_in <- c(seqs_at_least_one_primer_in, list_clone_seqs[[x]])
    seqs_all <- c(seqs_all, list_clone_seqs[[x]])
  }
}


## create fastq files for seqs_both_primers_in, seqs_at_least_one_primer_in, and seqs_all
create_fastq_file_from_seqs <- function(seqs, output_file_name) {
  
  fwd_fastq <- c()
  
  for (idx in 1:length(seqs)) {
    
    fwd_fastq <- c(fwd_fastq, paste0("@AB00001:123:12ABCDEFH:1:1:1:", idx, " 1:N:0:AAAAAAAA+GGGGGGGG"))
    
    fwd_fastq <- c(fwd_fastq, seqs[idx])
    
    fwd_fastq <- c(fwd_fastq, "+")
    
    tmp <- gsub("N", "#", seqs[idx])
    tmp <- gsub("[^#]", "I", tmp)
    
    fwd_fastq <- c(fwd_fastq, tmp)
    
  }
  
  writeLines(fwd_fastq, con = output_file_name)
}


create_fastq_file_from_seqs(seqs_both_primers_in, output_file_name = paste0(data_folder, sub_data_folder, "/", sub_data_folder, "_seqs_both_primers_in.fastq"))
create_fastq_file_from_seqs(seqs_at_least_one_primer_in, output_file_name = paste0(data_folder, sub_data_folder, "/", sub_data_folder, "_seqs_at_least_one_primer_in.fastq"))
create_fastq_file_from_seqs(seqs_all, output_file_name = paste0(data_folder, sub_data_folder, "/", sub_data_folder, "_seqs_all.fastq"))

for (x in names(list_clone_seqs)) {
  print(paste0(x, ": ", length(list_clone_seqs[[x]])))
}

# further filter out seqs_all by %N's 
filtered_seqs_all <- c()

for (s in seqs_all) {
  
  total_chars <- nchar(s)
  
  count_N <- sum(strsplit(s, NULL)[[1]] == "N")
  
  percentage_N <- count_N / total_chars
  
  if (is.nan(percentage_N) | percentage_N > thres_perc_N) {
    
    print(s)
    print(paste0("An empty sequence or Percentage of N's is at ", percentage_N * 100, "%!"))
    
  } else {
    filtered_seqs_all <- c(filtered_seqs_all, s)
  }
}

create_fastq_file_from_seqs(filtered_seqs_all, output_file_name = paste0(data_folder, sub_data_folder, "/", sub_data_folder, "_filtered_seqs_all.fastq"))



